# 算法题目

## 数组

### 二分法

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```cpp
#include <vector>

class Solution
{
public:
    int search(std::vector<int> &nums, int target)
    {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right)
        {
            int middle = (left + right) / 2;
            if (nums[middle] < target)
                left = middle + 1;
            else if (nums[middle] > target)
                right = middle - 1;
            else
                return middle;
        }
        return -1;
    }
};
```

**思路**：关注自己选取的区间，如果是左闭右闭那么while的循环条件取等不会没有意义，可以继续下去，给左右顶点赋值的时候因为两边都能取到所以都是+1或者-1操作。

### 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。*

*假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：*

更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。

*返回 k。*

```cpp
#include <vector>
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size();fastIndex++){
            if(nums[fastIndex]!=val){
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        } 
        return slowIndex;
    }
};
```

**思路：**双指针（快慢指针法）

### 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = INT32_MAX;
        int i = 0;
        int sum = 0;
        int sub = 0;
        for (int j = 0; j < nums.size();j++){
            sum += nums[j];
            while(sum>=target){
                sub = j - i + 1;
                result = result < sub ? result : sub;
                sum -= nums[i++];

            }
        }
        return result == INT32_MAX ? 0 : result;
    }
};
```

思路：**滑动窗口**，将j作为自区间的末尾循环遍历整个数组就只需要遍历一遍。

### 螺旋矩阵

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int i,j;
        int loop = n / 2;
        vector<vector<int>> nums(n, vector<int>(n, 0));
        int startx = 0, starty = 0, offset = 1, count = 1;
        while(loop--){
            for (j=starty; j < n - offset;j++){
                nums[startx][j] = count++;
            } // j=n-offset;
            for (i = startx; i < n - offset;i++){
                nums[i][j] = count++;
            }
            for (; j > starty; j--)
            {
                nums[i][j] = count++;
            }
            for (; i > startx; i--)
            {
                nums[i][j] = count++;
            }
            startx++;
            starty++;
            offset++;
        }
        if(n%2==1){
            nums[startx][starty] = count;
        }
        return nums;
    }
};
```

思路：每一圈都以一个左闭右开的区间进行打印，确保一致性。边界情况处理：中心位置元素单独讨论。

知识点：**vector初始化方式**：

```
//初始化一个size为0的vector
vector<int> abc;
//初始化size,但每个元素值为默认值
vector<int> abc(10);    //初始化了10个默认值为0的元素
//初始化size,并且设置初始值
vector<int> cde(10，1);    //初始化了10个值为1的元素

int a[5] = {1,2,3,4,5};
//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）
vector<int> b(a, a+5);

vector<int> a(5,1);
//通过a初始化
vector<int> b(a);

```



## 链表

### 移除链表元素

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *dummyHead = new ListNode(0);//创建新链表的方式
        dummyHead->next = head;
        ListNode *cur = dummyHead;
        while (cur->next != nullptr ){
            if(cur->next->val==val){
                ListNode *tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }else{
                cur = cur->next;
            }
        }
        ListNode* head1 = dummyHead->next;
        delete dummyHead;
        return head1;
    }
};
```

思路：特殊情况是head位置，那么为了统一操作引入**虚拟头部**。要删除某个接待你就必须把操作的节点设置为该节点的上一个节点。



### 设计链表

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)

```cpp
class MyLinkedList
{
public:
    MyLinkedList()
    {
        dummyHead = new ListNode(0);
        size = 0;
    }

    int get(int index)
    {
        if (index > (size - 1) || index < 0)
        {
            return -1;
        }
        ListNode *cur = dummyHead->next;
        while (index--)
        {
            cur = cur->next;
        }
        return cur->val;
    }

    void addAtHead(int val)
    {
        ListNode *newnode = new ListNode(val);
        newnode->next = dummyHead->next;
        dummyHead->next = newnode->next;
        size++;
    }

    void addAtTail(int val)
    {
        ListNode *newnode = new ListNode(val);
        ListNode *cur = dummyHead;
        while (cur->next != nullptr)
        {
            cur = cur->next;
        }
        cur->next = newnode;
        size++;
    }

    void addAtIndex(int index, int val)
    {
        if (index > (size) || index < 0)
        {
            return;
        }
        ListNode *newnode = new ListNode(val);
        ListNode *cur = dummyHead;
        while (index--) // 找到第index节点的写法
        {
            cur = cur->next; // 第零个结点cur->next指向的就是我们要的第零个，能保证cur是我们要插入的钱一个位置
        }
        newnode->next = cur->next;
        cur->next = newnode;
        size++;
    }

    void deleteAtIndex(int index)
    {
        if (index > (size) || index < 0)
        {
            return;
        }
        ListNode *cur = dummyHead; // 直到前一个节点的指针才能删掉这个节点。
        while (index--)
        {
            cur = cur->next;
        }
        ListNode *tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        size--;
    }

private:
    int size;
    ListNode *dummyHead;
};
```

### 



### 反转链表

https://leetcode.cn/problems/reverse-linked-list/submissions/563082122/

1. 常规双指针法

```cpp
class Solution
{
public:
    ListNode *reverseList(ListNode *head)
    {
        ListNode *cur = head;
        ListNode *pre = nullptr;
        ListNode *temp;
        while (cur)
        { // cur是null的时候就不需要再让cur的next指向pre
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp; // 注意顺序
        }
        return pre;
    }
};
```

思路：让指针的方向翻一翻。由于是单向链表所以要格外注意赋值顺序和增加临时指针。

2. 递归法

```cpp
class Solution
{
public:
    ListNode *reverse(ListNode *pre, ListNode *cur)
    {
        if (cur == nullptr)
            return pre;
        ListNode *temp = cur->next;
        cur->next = pre;
        reverse(cur, temp);//pre=cur;cur=temp;
    }
    ListNode *reverseList(ListNode *head)
    {

        return reverse(nullptr, head);
    }
};
```

思路：递归里面套函数的时候可以对照正常写法的变量转化

### 删除倒数第n个节点

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

```cpp
class Solution
{
public:
    ListNode *removeNthFromEnd(ListNode *head, int n)
    {
        ListNode *dummyhead = new ListNode(0);
        dummyhead->next = head;
        ListNode *slow = dummyhead;
        ListNode *fast = dummyhead;
        n++; // 防止越界，让fast走n+1步
        while (n-- && fast != nullptr)
            fast = fast->next;
        while (fast != nullptr)
        {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummyhead->next;
    }
};
```

思路：双指针法（快慢指针帮助定位）。让fast走n+1步，慢指针再跟着快指针走到null时，慢指针就就能指向倒数第n个节点的上一个节点。





### 环形链表

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

```cpp
        ListNode *fast = head;
        ListNode *slow = head;
        while (fast!=nullptr&&fast->next!=nullptr)
        {
            fast = fast->next->next;
            slow = slow->next;
            if(fast==slow){
                ListNode* index1 = fast;
                ListNode *index2 = head;
                while(index1!=index2){
                    index1 = index1->next;
                    index2 = index2->next;

                }
                return index1;
            }
        }
        return nullptr;
```

思路：双指针，快指针比慢指针多走一步就不会跳过慢指针，两者如果相遇就说明有环存在。根据公式推导，当快指针与慢指针相遇，刚好就在环的起点。





## 哈希表

哈希表常用于给你有一个元素判断在集合里是否出现过

1. 数组：数值不是很大
2. set：数值也不是很大但是数值很分散；数据相对比较大

### 有效的字母异位词

[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/description/)

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int harsh[26] = {0};
        for (int i = 0; i < s.size(); i++)
        {
            harsh[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++)
        {
            harsh[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++)
        {
            if(harsh[i]!=0)
                return false;
        }
        return true;
        }
};
```

思路：因为规定了小写字母，他们的ASCII码都是连续的，所以可考虑用数组来记录。把字符映射到数组哈希表的索引上，遍历s时先填入，遍历t时删除，如果最后哈希表里面出现不是0的元素就不是字母异位词。

### 两个数组的交集

[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

1. 用set：不确定数据多大

   问题：每放入一个值就要进行哈希运算对应一个内存空间同时是还要开辟一个新空间

```cpp
class Solution
{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2)
    {
        unordered_set<int> result;
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num:nums2){
            if(nums_set.find(num) !=nums_set.end()){
                result.insert(num);
            }
        }
        return vector<int>(result.begin(), result.end());
    }
};

```

**知识点**：

set（include<set>）

**插入元素**：使用 `insert()` 方法。`set` 会自动排序并去重。

**遍历元素**：可以用范围for循环或迭代器。

**查找元素**：使用 `find()` 方法，如果找到则返回元素的迭代器，否则返回 `set.end()`。

> set.end()主要用于表示超过容器范围的一个位置

**删除元素**：使用 `erase()` 方法。

**初始化**：

```cpp
std::set<int> mySet = {10, 20, 30, 40};
 std::set<int> mySet(vec.begin(), vec.end());//用迭代器范围
std::set<int> set2(set1);//拷貝
std::set<int> set2(std::move(set1));//移动拷贝
std::set<int> mySet(arr, arr + 4);//数组迭代器
```

**空集初始化**：`std::set<int> mySet;`

**`initializer_list` 初始化**：`std::set<int> mySet = {10, 20, 30};`

**通过迭代器范围初始化**：`std::set<int> mySet(vec.begin(), vec.end());`

**拷贝构造初始化**：`std::set<int> set2(set1);`

**移动构造初始化**：`std::set<int> set2(std::move(set1));`

**通过数组初始化**：`std::set<int> mySet(arr, arr + size);`

2. 用数组：有数据大小<1000的规定

   直接用下标来做哈希映射

```cpp
//用数组，
class Solution
{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2)
    {
        unordered_set<int> result;
        int harsh[1005] = {0};
        for (int i = 0; i < nums1.size(); i++)
        {
            harsh[nums1[i]]=1;
        }
                for (int i = 0; i < nums2.size(); i++)
        {
            if(harsh[nums2[i]]==1){
                result.insert(nums2[i]);
            };
        }
        
        return vector<int>(result.begin(), result.end());
    }
};
```



### 两数之和

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/submissions/563762743/)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++)
        {

            auto iter = map.find(target - nums[i]);
            if(iter!=map.end()){
                return {iter->second, i};
            }
            map.insert(pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```

思路：每遍历一个元素都要看看另一个数是不是已经被遍历过了，所以需要有一个容器存放遍历过的数。并且同时需要知道元素和下标，通过元素找下标，用map将元素值作为key，查找方便，将下标作为value。用unorderedmap复杂度最低。



**知识点**：`std::map` 中的每个元素实际上是一个 `std::pair`，其中包含两个部分：

1. `first` 表示 **键**（key）。
2. `second` 表示 **值**（value）。

假设你有一个指向 `std::map` 元素的迭代器（如 `auto it`），使用 `it->first` 可以访问这个键值对的键，`it->second` 可以访问它的值。

1. **`std::map` 初始化方式**

1.1. **默认构造函数**

创建一个空的 `std::map`：

```
std::map<int, std::string> myMap;
```

1.2. **初始化列表**

使用键值对列表来初始化 `std::map`：

```
std::map<int, std::string> myMap = {
    {1, "one"},
    {2, "two"},
    {3, "three"}
};
```

1.3. **拷贝构造函数**

通过另一个 `std::map` 初始化：

```
std::map<int, std::string> copyMap(myMap);
```

1.4. **范围初始化**

使用两个迭代器初始化 `std::map`：

```
std::vector<std::pair<int, std::string>> vec = {
    {1, "one"}, {2, "two"}, {3, "three"}
};
std::map<int, std::string> myMap(vec.begin(), vec.end());
```

------

2. **常用函数**

2.1. **插入元素**

2.1.1. **使用 `operator[]` 插入或更新元素**

使用 `[]` 可以直接插入或更新一个键值对：

```
myMap[4] = "four";  // 插入键为4，值为"four"的键值对
myMap[2] = "updated";  // 更新键为2的值
```

2.1.2. **使用 `insert()` 插入元素**

通过 `insert()` 插入键值对：insert（pair<T,T>(i,j)）

```
myMap.insert({5, "five"});
auto result = myMap.insert({2, "two"});  // 如果键2已存在，插入失败,因为key不可重复，不可修改
```

2.2. **查找元素**

2.2.1. **使用 `find()` 查找元素**

返回指向指定键的迭代器。如果未找到，返回 `end()`：

```cpp
auto it = myMap.find(2);//找键值为2
if (it != myMap.end()) {
    std::cout << "Found: " << it->first << ": " << it->second << std::endl;
}
```

2.2.2. **使用 `count()` 判断键是否存在**

`count()` 返回键的出现次数（对于 `std::map`，返回值只能是 0 或 1）：

```
if (myMap.count(2)) {
    std::cout << "Key 2 exists" << std::endl;
}
```

2.3. **删除元素**

2.3.1. **使用 `erase()` 删除指定键的元素**

可以通过键或迭代器删除元素：

```
myMap.erase(2);  // 删除键为2的元素
```

2.3.2. **使用 `clear()` 清空整个 `map`**

清空所有元素：

```
myMap.clear();  // 清空 map
```

2.4. **遍历元素**

2.4.1. **使用范围 `for` 循环遍历**

```
for (const auto& pair : myMap) {
    std::cout << pair.first << ": " << pair.second << std::endl;
}
```

2.4.2. **使用迭代器遍历**

```
for (auto it = myMap.begin(); it != myMap.end(); ++it) {
    std::cout << it->first << ": " << it->second << std::endl;
}
```

2.5. **获取 `map` 的大小和状态**

2.5.1. **使用 `size()` 获取元素个数**

```
std::cout << "Size of the map: " << myMap.size() << std::endl;
```

2.5.2. **使用 `empty()` 检查 `map` 是否为空**

```
cpp复制代码if (myMap.empty()) {
    std::cout << "The map is empty" << std::endl;
}
```

2.6. **其他函数**

2.6.1. **访问第一个和最后一个元素**

- `begin()` 返回指向第一个元素的迭代器：

  ```
  cpp复制代码auto it = myMap.begin();
  std::cout << it->first << ": " << it->second << std::endl;
  ```

- `end()` 返回指向容器末尾之后的迭代器，不能解引用，用于判断遍历结束。

2.6.2. **自定义排序**

`std::map` 默认按 默认按键的升序排序，但可以自定义排序规则：

```cpp
struct CompareDesc {
    bool operator()(const int& lhs, const int& rhs) const {
        return lhs > rhs;  // 按降序排列
    }
};
std::map<int, std::string, CompareDesc> myMap = {{1, "one"}, {2, "two"}};
//或者
    std::map<int, std::string, std::function<bool(int, int)>> myMap([](int lhs, int rhs) { return lhs > rhs; } ） // 降序std::function：用作 std::map 的第三个模板参数，用于接收 Lambda 表达式作为比较函数。

```



### 三数之和

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)

```cpp
class Solution
{
public:
    vector<vector<int>> threeSum(vector<int> &nums)
    {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++)
        {
            if (nums[i] > 0) // 三元组里面最小的数都大于0了不行
                return result;
            // 三元素里面的值可以相等，找前面有没有相等的元素，前面相等说明前面和自己相等的这个首元素已经做好了找三元组的过程，这时候跳过没有问题
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) // 如果left right重复逻辑放在这里面可能直接导致right<=left从而漏掉{000}
            {
                if (nums[i] + nums[left] + nums[right] > 0)
                    right--;
                else if (nums[i] + nums[left] + nums[right] < 0)
                    left++;
                else
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                while (right > left && nums[right] == nums[right - 1])
                    right--;
                while (right > left && nums[left] == nums[left + 1])
                    left++;
//收获一个结果之后，双指针同时收缩
                left++;
                right--;
            }
        }
        return result;
    }
};
```

思路：这里用哈希表很难。用双指针法：先排序，后确定左右区间再不断缩小。

关键是去重操作

### 四数之和

[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/description/)

```cpp
class Solution
{
public:
    vector<vector<int>> fourSum(vector<int> &nums, int target)
    {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++)
        { // 剪枝
            if (nums[k] > target && nums[k] > 0 && target > 0)
            {
                break;
            }
            if (k > 0 && nums[k] == nums[k - 1])
                continue;
            for (int i = k + 1; i < nums.size(); i++)
            {
                if (i > k + 1 && nums[i] == nums[i - 1])
                    continue;
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left)
                {
                    if (nums[k] + nums[i] + nums[left] + nums[right] > target)
                        right--;
                    else if (nums[k] + nums[i] + nums[left] + nums[right] < target)
                        left++;
                    else
                    {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        while (right > left && nums[right] == nums[right - 1])
                            right--;
                        while (right > left && nums[left] == nums[left + 1])
                            left++;
                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }
};
```

思路：还是双指针，不过最外层再套一层循环以及剪枝操作和去重操作
